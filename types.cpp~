#include "types.h"
#include <charconv>
#include <cwchar>
using namespace std;

static string item, val;
void unk(string s) {
  // cerr<<s<<"  unknow select"<<endl;
  cerr << s << endl;
  exit(1);
}
bool gettok() { // read conf
  regex conf("(.+):([0-9a-z \\+\\*/-]+)?.*");
  smatch sm;
  string s;
  if (getline(cin, s)) {
    if (regex_match(s.cbegin(), s.cend(), sm, conf)) {
      // clog << "val: " << sm[1] << " = " << sm[2] << endl;
      item = sm[1], val = sm[2];
      if(item=="end"){
	return false;
      }
    } else {
      unk("not matched conf");
    }
    return true;
  } else {
    return false;
  }
}
bool cond::check(int x) { return l < x && x < r; }
void init(types x) {
  for (int i = 0; i < 256; ++i) {
    x.vals[i].l = x.vals[i].r = x.calcvals[i] = x.is_def[i] = 0;
    x.calcval[i] = NULL;
  }
}
types::types() {
  // for (int i = 0; i < 256; ++i) {
  //   vals[i].l = vals[i].r = 0;
  //   calcval[i] = NULL;
  // }
  init(*this);
};
types::~types() {}
bool types::check() {
  for (int i = 0; i < 256; ++i) {
    if (vals[i].l == 0 && vals[i].r == 0) {
      continue;
    }
    if (calcval[i]) {
      calcvals[i] = calcval[i]->getv();
    }
    cout<<i<<":"<<calcvals[i]<<endl;
    if (!vals[i].check(val[i])) {
      return false;
    }
  }
  return true;
}
void cleanup() {
  for (auto i : tps) {
    // clog << "clean TYPE=> " << i.first << ":" << endl;
    auto &sec = i.second;
    for (int i = 0; i < 256; ++i) {
      // clog << i << " ";
      if (sec.calcval[i]) {
        // clog << "d";
        delete sec.calcval[i];
        sec.calcval[i] = NULL;
        // clog << " ok" << endl;
      }
    }
  }
}
map<string, types> tps;
map<string, vector<size_t>> to_random;
void load() {
  // clog << "loading ..." << endl;
  bool in = false;
  string typenow = "";
  types tmp;
  init(tmp);
  int to_def;

  while (gettok()) {
    // clog<<item<<' '<<val<<endl;
    if (item == "type") {

      // clog << "type: " << val << endl;
      in = true;
      typenow = val;
    } else if (isdigit(item[0]) && (item[1] == 'l' || item[1] == 'r')) {
      // clog << "item: " << item << endl;
      if (item[1] == 'l') {
        tmp.vals[item[0] - '0'].l = stoi(val);
      } else if (item[1] == 'r') {
        tmp.vals[item[0] - '0'].r = stoi(val);
      }
    } else if (item == "def") {
      // clog << "val:" << val << endl;
      to_def = stoi(val);
    } else if (item == "equ") {
      tmp.is_def[to_def] = true;
      tmp.calcval[to_def] = build(build(val), tmp.calcvals);
      // clog << "val:" << val << endl;
    } else if (item == "for") {
      tmp.format = val;
    } else if (item == "endtype") {
      tps.insert({typenow, tmp});
      init(tmp);
    } else {
      unk("unknow: " + item + ":" + val);
    }
  }
  for (auto i : tps) {
    auto &sec = i.second;
    auto &fir = i.first;
    for (int i = 0; i < 256; ++i) {
      // cout<<sec.vals[i].l<<' '<<sec.vals[i].r<<endl;
      if (!(sec.vals[i].l == 0 && sec.vals[i].r == 0)) {
        // cout<<i<<','<<sec.is_def[i]<<endl;
        if (!sec.is_def[i]) {
          to_random[fir].push_back(i);
        }
      }
    }
  }
}

void show() {
  for (auto i : tps) {
    cout << "TYPE=> " << i.first << ":" << endl;

    auto &sec = i.second;
    auto &fir = i.first;
    for (int i = 0; i < 256; ++i) {
      if (!(sec.vals[i].l == 0 && sec.vals[i].r == 0)) {
        cout << i << " ->" << sec.vals[i].l << "~" << sec.vals[i].r << endl;
        if (sec.is_def[i]) {
          // cout << "is_def" << endl;
          // ??????????????sec.calcval[i]->show();
        }
      }
    }
    cout << "to rand:" << endl;
    for (auto i : to_random[fir]) {
      cout << i << ' ';
    }
    cout << endl;
  }
}
